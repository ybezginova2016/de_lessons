/*
Что такое процедуры и функции в БД?

Процедуры и функции в БД это примерно то же, что и функции в других языках программирования —
блоки кода, которые выполняют определённую задачу и исполняются при вызове в запросе. Процедуры
и функции во многом похожи друг на друга, но отличаются набором возможностей и синтаксисом.
Процедуры в отличие от функций не имеют возвращаемого значения. Для вызова процедуры нужно
использовать ключевое слово CALL, а функцию достаточно использовать в выражении SELECT.
Как создать процедуру?

Для создания новой процедуры используйте команду CREATE PROCEDURE. Затем следует название процедуры,
а далее — тело процедуры. Оно начинается с ключевых слов LANGUAGE SQL AS и обрамляется символами $$.
В теле могут быть использованы любые запросы DML и DDL. При этом в отличие от функций (как в Python,
так и в SQL), процедуры не имеют возвращаемого значения — это означает, что все действия будут
происходить строго в блоке кода процедуры и результат выполнения кода нельзя передать в качестве
значения в запрос или в другую процедуру.

Например:
*/

CREATE PROCEDURE example_procedure(a text, b text)
LANGUAGE SQL
AS $$
INSERT INTO example_table_1 VALUES (a);
INSERT INTO example_table_2 VALUES (b);
INSERT INTO example_table_3 VALUES (a || '_' || b);
$$;

/*
С помощью этой процедуры вы вставите данные одновременно в три таблицы,
при этом для третьей таблицы строки a и b будут объединены.
Для вызова процедуры воспользуйтесь командой CALL.
Для примера вызовите процедуру выше:
*/
CALL example_procedure('test1', 'test2')
-- https://www.postgresql.org/docs/current/sql-createprocedure.html

/*
Как создать функцию?

Значительное отличие функций от процедур в том, что функции имеют возвращаемое значение.
Их можно вызвать в теле запроса DML (SELECT, INSERT, UPDATE, DELETE). Для создания новой
функции используйте ключевые слова CREATE FUNCTION или CREATE OR REPLACE FUNCTION,
чтобы изменить определение существующей функции. Некоторые атрибуты функции вы можете изменять
с помощью ключевого слова ALTER. Пример функции:
*/
CREATE FUNCTION example_function(str text, symbol char) RETURNS int4 AS
$$
  select array_length(regexp_split_to_array(str , '\' || symbol || '+' ), 1);
$$
LANGUAGE sql;

/*
    Для удаления функции выполните команду DROP FUNCTION имя_функции. Более подробно о синтаксисе и
    возможностях функций вы можете узнать здесь.
*/

/*
Как создать триггер?

В предыдущих уроках мы не раз упоминали триггеры. Давайте рассмотрим их более детально.
    Триггер — это действие, которое совершается в ответ на события изменения данных в БД.
    Триггер может выполнять блоки кода, например, процедуры, при запросе UPDATE, INSERT, DELETE, TRUNCATE
    одной из таблиц. Запрос SELECT данные не изменяет, поэтому для него нельзя создать триггер.

Существует три типа триггеров:
BEFORE — исполняет блок кода до запроса на изменение данных.
AFTER — исполняет блок кода после запроса на изменение данных.
INSTEAD OF — исполняет блок кода вместо запроса на изменение данных.

Важная часть конструкции определения триггера — команда FOR EACH ROW, которая говорит, что действие
    будет исполняться для каждой строки или для одного запроса, если указано FOR EACH STATEMENT.
    Также можно указать условие срабатывания триггера с помощью ключевого слова WHEN.
Заключительная составляющая триггера — команда EXECUTE PROCEDURE, которая вызывает специально
    созданную функцию для триггера. Функция для триггера отличается от обычной функции тем, что
    имеет возвращаемое значение TRIGGER. Удобнее всего писать код триггерной функции с помощью диалекта PL/pgSQL.
    Важное свойство триггерной функции — вы можете обращаться к старому и новому значению изменяемых данных
    с помощью ключевых слов OLD и NEW соответственно. Создать триггер можно с помощью CREATE TRIGGER.
    Рассмотрим на примере. В первую очередь создадим триггерную функцию:
*/

CREATE OR REPLACE FUNCTION log_update_function_trigger() RETURNS TRIGGER AS $$
    BEGIN
        IF (TG_OP = 'UPDATE') THEN
            INSERT INTO example_table_5 VALUES (NEW.value, current_timestamp);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

/*
Обратите внимание, что диалект триггерной функции указан как PL/pgSQL в команде LANGUAGE plpgsql.
    Тело триггерной функции в диалекте PL/pgSQL заключено между ключевыми словами BEGIN и END.
    Специальная переменная TG_OP содержит тип операции, в этом случае — UPDATE. При запросе UPDATE
    вы будете вставлять данные о новом значении и времени его изменения в таблицу example_table_5
    и возвращать триггеру новое заданное значение командой RETURN NEW.
Вы создали триггерную функцию, а теперь попробуем создать сам триггер, который будет её вызывать:
*/

CREATE TRIGGER log_update_some_value
    AFTER UPDATE ON example_table_4
    FOR EACH ROW
    EXECUTE PROCEDURE log_update_function_trigger();

/*
Создан триггер для таблицы example_table_4, который будет срабатывать после обновления значений для
каждой строки в таблице и вызывать триггерную функцию log_update_function_trigger(). Значения для функции, такие как тип операции, новые и старые значения будут переданы в триггерную функцию неявно: если вы выполните запрос UPDATE для таблицы example_table_4, то в таблицу example_table_5 автоматически вставится обновлённое значение с временем изменения.
Процедуры, функции и триггеры — мощные инструменты для автоматизации процессов манипуляции данными в БД. Вы можете инкапсулировать сложную и нереляционную логику в процедуры и функции, реализовать несколько триггеров на таблицы, чтобы автоматизировать процесс наполнения данных или проверку их консистентности и многое другое. Эти сущности в БД расширяют возможности обычного SQL.
*/